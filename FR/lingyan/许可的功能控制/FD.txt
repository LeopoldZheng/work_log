
架构图：
https://www.processon.com/v/68d62f74a225f06bfca6baf9

其他：
租户id=0 表示 不区分租户


============ app: 许可的功能定义 ===============
1. app打包：
# lingyan.meta.yml

# 表示安装和请求需要匹配如下license。目前灵岩已预装了8000和8001，只要安装了平台许可即有权限安装和访问app
# 目前的逻辑：  安装平台许可 -> 激活在gmd定义的预装基础版license -> 安装app包时会匹配到metadata的license -> 允许安装、hillos-core添加访问控制列表
official_license: 8000
trial_license: 8001

license:
  items:
    - license_id: 8000  # 预装的基础包（正式版）
      function_id: 1
    - license_id: 8001  # 预装的基础包（试用版）
      function_id: 1
    - license_id: 8010  # 进阶包许可
      function_id: 2
  function:
    - function_id: 1
      description: 基础包功能
      # 与agent无关的功能，可以在ai-gateway统一校验
	  common_type:
	    urls:
	      - url: /knowledge/*
		    configuration:
	  # 与agent相关的功能；ai-gateway拿不到plan请求的动态规划出的agent_id，只能在app那边触发校验
      agent_type:
	    - agent_id: xxx
  	      urls:
	        - url: xxx
	  	    configuration: # 描述同一功能、不同许可下的资源配置。如试用许可的数据分类分级字段总数限量不同
    - function_id: 2
      description: 进阶包功能
  	  common_type:
  	    urls:
  		  - url: /knowledge/*
		    configuration:
      agent_type:
	    - agent_id: xxx
	      urls:
	        - url: xxx
		      configuration:

============ ai-gateway: 许可的配置存储与更新 ===============
本地：
  预置(基础包): 安装平台许可后，hillos-core会激活预装的许可，并推送许可信息给ai-gateway入库。 安装完成后即可访问基础包的功能
  非预置(进阶包、旗舰包等): 用户安装进阶包许可后，hillos-core推送许可信息给ai-gateway入库。 安装完成即可访问进阶包的功能。
云端：
  预置(基础包): ai-gateway预装好的许可。 开通租户后即可访问基础包的功能
  非预置(进阶包、旗舰包等): 租户订阅进阶包后，云景推送许可信息给ai-gateway入库。 订阅完成即可访问进阶包的功能。


# 云端预装的license配置: application-cloud.yml
app_license:
  cloud_preload_license:
    - license_id: 8000
      description: 正式版
      type: DATE
      time: 2100-12-31 （NULL就是永久）

2. ai-gateway启动时加载数据
  - 获取业务锁（gmd提供的分布式锁）
  - 加载 cloud_preload_license 预装配置，查表 t_app_license_tenant where (租户id=0, license_id=预置license_id)
    - 查不到，则入库 t_app_license_tenant VALUES(租户id=0, 预置license_id, expired_time, expired_time_type, order_time)
    - 查的到，只更新字段 expired_time, expired_time_type
  - 查表 t_app_license_tenant，把已安装的license_id存到redis里：  app_license:{租户id}:license_id    值：  {license_id}
  - 重建redis的2类key的数据：把 t_app_license_tenant、t_app_license_function 数据捞到redis里

3. app安装场景：
- manage-center推送appid, metadata
- 获取业务锁
- app metadata入库 t_app_license_function VALUES(appid, metadata)
- 加载许可的功能列表：
  - 查表 t_app_license_tenant 获取 (租户id, license_id, expired_time)
  - 查 metadata 获取 url, agent_id, configuration
  - 入redis:
    - app_license:{租户id}:common_type:{license_id}:{appid}:{url}        值：  {expired_time} + {configuration}
    - app_license:{租户id}:agent_type: {license_id}:{appid}:{agent_id}   值：  {expired_time} + {configuration}

4. 云端用户购买进阶包场景：
- 云景推送数据：租户id, license_id, expired_time, expired_time_type, order_time
- 获取业务锁
- 入库 t_app_license_tenant VALUES(租户id, license_id, expired_time, expired_time_type, order_time)
- 根据 license_id 查 metadata 获取 appid, url, agent_id, configuration
- 入redis:
  - app_license:{租户id}:common_type:{进阶license_id}:{appid}:{url}         值：  {expired_time} + {configuration}
  - app_license:{租户id}:agent_type: {进阶license_id}:{appid}:{agent_id}    值：  {expired_time} + {configuration}
  - app_license:{租户id}:license_id    值：  {license_id}

5. 本地用户安装许可场景：
  - hillos-core推送 (license_id, expired_time, expired_time_type, order_time) 到kafka  （预装和非预装的都要推送）
  - ai-gateway 订阅kafka
  - 获取业务锁
  - 入库 t_app_license_tenant VALUES(租户id=0, license_id, expired_time, expired_time_type, order_time)
  - 根据 license_id 查 metadata 获取 appid, url, agent_id, configuration
  - 入redis
    - app_license:{租户id=0}:common_type:{进阶license_id}:{appid}:{url}         值：  {expired_time} + {configuration}
    - app_license:{租户id=0}:agent_type: {进阶license_id}:{appid}:{agent_id}    值：  {expired_time} + {configuration}
    - app_license:{租户id=0}:license_id    值：  {license_id}

============ ai-gateway: 许可的功能控制 ===============
6. 用户请求场景：
    ai-gateway 做 common_check:
      - 要求请求带上租户id、appid
      - 从redis读取已安装的license_id： app_license:{租户id}:license_id
      - 先找预置license的redis key    app_license:{租户id=0}:common_type:{预置license_id}:{appid}:{url}
      - 再找进阶license的redis key    app_license:{租户id}:common_type:{进阶license_id}:{appid}:{url}
      - 若找到，校验过期时间和configuration
      - 找不到，拒绝请求
    app 触发 agent_check：
      - 要求请求带上租户id、appid、agent_id
      - 从redis读取已安装的license_id： app_license:{租户id}:license_id
      - 先找预置license的redis key    app_license:{租户id=0}:agent_type: {预置license_id}:{appid}:{agent_id}
      - 再找进阶license的redis key    app_license:{租户id}:agent_type:{进阶license_id}:{appid}:{agent_id}
      - 若找到，校验过期时间和configuration
      - 找不到，拒绝请求


=========== 其他业务场景 ==================================

7. 租户合并场景：
  - 获取业务锁
  - 主租户：
    - 查询副租户剩余时间，把剩余时间累加到主租户上，更新mysql和redis
  - 删除副租户：
    - t_app_license_tenant 根据租户id删除数据
    - redis 删除key: app_license:{租户id}*

8. 每日定时任务：删除过期数据：
  - 获取业务锁
  - 查询 t_app_license_tenant 的过期时间和下单时间，删除mysql和redis的过期数据

9. 查询有功能权限的应用和智能体（许可展示、plan图获取可用的agent列表）
  - 请求带上{租户id}（为0则表示本地灵岩用户）
  - 调用ai-gateway接口getAvaliableAppAgent
    ai-gateway提供一个查询可用app及agent的接口getAvaliableAppAgent，参数是租户id
    - 先查安装了哪些license
      根据租户id={0, 租户id参数} 查表 t_app_license_tenant 获取 license_id 和过期时间
    - 根据license查app的metadata
      根据 license_id 查表 t_app_license_function，获取可用的app及agent



